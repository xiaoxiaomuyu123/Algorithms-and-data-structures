# 三、排序算法
## 1 排序算法介绍
将无序状态转换成有序状态：如 数字顺序，字典顺序，拼音顺序。排序的应用：数据展示，数据分析。
- 分类
    - 按时间复杂度分类：
        - O(n^2)：插入排序，比较排序，冒泡排序
        - O(nlg): 合并排序，快速排序，分块排序
        - O(n)：桶排序，基数排序
    - 基于比较
        - 基于比较的排序算法：插入排序，比较排序，冒泡排序，合并排序，快速排序，分块排序。
        - 其他：桶排序，基数排序
    - 原地/非原地
        - 都在原地做交换：插入排序，比较排序，冒泡排序，快速排序
        - 非原地，创建一个新数组: 合并排序，桶排序，分块排序，基数排序
    - 稳定/非稳定
## 2 基于比较的排序算法
每一个元素都像一个黑盒子，不需要准确的知道每个元素究竟是什么，只需要能够两两比较他们的大小。  
排序 a, b, c —— 决策树。算法的所有可能形成了一棵二叉树，一共有 n！个结果，也就是叶子节点。排序 a, b, c  其实就是 他们的全排序。最坏的情况需要比较的次数就是树的高度。
## 3 快速排序
- 类似于合并排序，和二分查找也非常类似
他们的相同点：
    - 他们本质上是一类算法，都是 分治策略 算法。分治策略，就是把原来规模为 n 的问题，拆分成几个部分
    - 平均执行时间都是 O(nlgn)  
不同点：
    - 快速排序的空间复杂度是 O(1)，算法基于原来数组的位置交换，而不是创建新的数组
    - 快速排序的常数时间更少
    - 合并排序更容易被迁移到并发环境中
- 关键子问题：怎么根据中心点拆分数组  
数组：[10, 80, 30, 90, 40, 50, 70]  选取一个中心点，把小于等于中心点的数字放在中心店左边，大于等于的放在中心点的右边。上面的这个步骤构成了快速排序的核心。这里注意不要创建新的数组，而是希望通过交换来完成。  
    - **方案**：
        - 以 70 为中心点，在原数组的基础上，先从左边找，找到第一个大于 70 的数字，再从右边找找到第一个小于 70 的数字，将两个元素的位置做一个交换。
        - 重复上述步骤，找第二个，第三个...
        - 最后，70 和左边第一个大于 70 的数字做交换
        - 这样的话就有两个变量：i, j。i 由左向右走，j 由右向左走。  

   - **设计循环不变式**
        -

   - **问题抽象**  
   `function partition(arr, lo, hi)`  
   - arr 需要排序的数组
   - lo 开始的位置，闭区间
   - hi 结束的位置，开区间
   - 返回 中心所在的位置
   - 副作用：[lo，hi) 被中心点分成两个区域
   ```
   function swag(arr, i, j) {
       [arr[i], arr[j]] = [arr[j], arr[i]]
    }

    function partition(arr, lo, hi) {
        // 定义中心点
        const pivot = arr[hi - 1];
        let i = lo,
        j = hi - 1;
        while (i !== j){
            if(arr[i] <= pivot) {
                i++;
            } else {
                swag(arr, i, --j);
            }
        }
        swag(arr, j, hi-1);
        return j;
    }

    const arr1 = [10, 50, 30, 90, 40, 80, 70];
    const arr2 = [10, 50, 30, 90, 40, 80, 70];
    partition(arr1, 0, 7)
    partition(arr2, 0, 3)
    console.log(arr1, arr2)
   ```
- 关键问题解决后，后面就是分治策略：    
    - 前面将整个数组根据中心点拆成了两个数组
    - 对这两个数组用相同的方法再继续拆分
    - 在拆分过程中就把整个数组排序了
- 完整的快速排序问题抽象：  
`function quickSort(arr)`
    - arr：主要排序的数组
    - 返回值：无
- 代码实现：  
在上面关键子问题的代码基础上再加上下面的代码：  
```
function quickSort(arr, lo = 0, hi = arr.length) {
    // 判断一下需要排序的元素个数，如果小于 2，就不需要排序，直接返回就好了
    if((hi - lo) < 2) {
        return
    }
    const p = partition(arr, lo, hi);
    quickSort(arr, lo, p);
    quickSort(arr, p, hi);
}

const arr3 = [10, 50, 30, 90, 40, 80, 70];
quickSort(arr3);
console.log(arr3)
```
- 对比于前面的归并排序，快速排序的好处是，拆分完数组的同时就已经排好序了，因为没有创建新的数组，就是再原来的数组里面进行交换位置。而归并排序要先拆分，再合并，才能排好顺序。
- **快速排序 复杂度分析**   
    - 最好的情况是 O(nlgn)
    - 最坏的情况是 O(n^2)
    - 平均情况是 O(nlogn)
    - 空间复杂度是 最好：O(logn)，最坏是 O(n)

- 快速排序优化：  
他是一个不平衡树，优化成平衡树，也就是让拆分更加平均。
    - 随机打乱数组，因为用户输入数组的时候可能有偏向性，所以我们打乱数组，去掉这种偏向性
    - 使用中位数做重点，但这样会有一个累加的 O(n) 的消耗。因为会多次调用 partion（）
    - 找三个数，区中间的数字

## 3.4 计数排序  
- 特点
    - 属于非比较性排序
    - 待排序集合键（key，权重）为整数
    - 键的最大值不能超过 K
    - time ~ O(n+k)；space ~ O(n+k)
- 计数排序的过程：
- 问题抽象：
`function counting_sort(arr)`  
    - arr 要排序的数组
    - 返回：结果数组
- 代码：  
```
function counting_sort(A) {
    // 找到 A 数组的最大值
    const max = Math.max(...A);
    // 定义 累计数组 B
    const B = Array(max + 1).fill(0);
    // 定义回写数组 C
    const C = Array(A.length);
    // 计算 A 里面数字出现的次数
    A.forEach((item, index) => B[A[index]]++);
    // 累加 B 数组
    for (let i = 1; i < B.length; i++) {
        B[i] = B[i-1] + B[i]
    }
    // 将 B 的结果取出，写入 C 数组中
    for (let j = 0; j < A.length; j++){
        const p = B[A[j]] - 1; // 回写的位置
        C[p] = A[j];
        B[A[j]]--; // 新回写的位置
    }
    return C;
}


const A = [6, 0, 6, 5, 3, 3, 2, 2, 1, 7, 7, 7];
console.log(counting_sort(A));
```
- 什么时候返回数组，什么时候不返回数组呢?
    - 当我们对原数组进行操作的时候，就不用返回
    - 当我们是将原数组的数回写到一个新的数组就要返回值。
## 5 基数排序
- 特点：
    - 是非比较型排序的算法
    - 按照相同位有效数字的值分组排序
    - Time ~ O(wn)   Space ~ O(w+n)
- 排序方法描述：
    - 1. 按照所有数字的最后一位从小到大进行排序。
    - 2. 在上面的基础上，根据倒数第二位的数字大小从小到大进行排序。
    - 3. 以此类推，一直到根据第一位数字的大小从大到小进行排序。
    - 如果比较位数相同，就保持之前的排序，如果比较位数不同就重新排序。
- 问题抽象：
```
function radix_sort(A) {
    for(let i = 1; i <= A中的有效数字; i++) {
        根据右边数第 i 位有效数字排序，且要用一种稳定的排序算法。
        就是说，后面的排序不能影响之前的结果。
    }
}
```
- 核心问题是：如何取到有效数字？比如如何取到 6789 中第二位有效数字
    - 6789 % 1000 = 789； % 取余数
    - 789 / 100 = 7.89； / 相除的结果
    - 结果向下取整，就得到第二位有效数字
- 代码实现
```
function radix_sort(arr) {
    let max = Math.max(...arr);
    let buckets = Array.from({length:10}, () => []);
    let m = 1;
    while(m < max) {
        // 循环 arr 里面的数字，根据 digital 将里面的数字放在桶中
        arr.forEach(number => {
            let digital = Math.floor((number % (m * 10)) / m);
            buckets[digital].push(number);
        })
        // 把同里面的数字按照顺序拿出来
        let j = 0;
        buckets.forEach(bucket => {
            while(bucket.length > 0) {
                arr[j++] = bucket.shift();
            }
        })
        m = m * 10;
    }
}

let arr = [10, 23, 34, 78, 345, 234, 435, 24]
radix_sort(arr);
console.log(arr)
```
## 6 桶排序
- 特点：
    - 非比较型排序
    - 排序键为数字的集合
    - 计数排序是一种特殊的桶排序（桶的数量 = 数组中元素最大值 + 1）
- 桶排序的过程
将数字放入不同的桶中，对同里面的数字进行排序，一般是插入排序。
    - 了解输入的数字，把数字划分到不同的桶中。观察最大值，来拆成不同的桶，k = 桶的个数，S = 不同桶之间的跨度
    - 遍历数组，把数组中的元素放在对应的桶中。可以使用关联的链表或数组来实现。
    - 对砼中的数字进行排序，一般是插入排序，因为插入排序的空间复杂度是 O(1)，并且再数字量很小的情况下，小号的时间也不高。
    - 再把每个同种的数字依次取出来
- 复杂度分析：
    - 时间复杂度：最坏情况：O(n^2)；最好的情况：O(n+k)；平均情况：O(n+k)；
    - 空间复杂度：O(n+k)
- 问题抽象：
`function bucket_sort(arr, k, s)`  
    - arr: 需要排序的数组
    - k：桶的数量
    - S：通的范围
    - 返回：排好序的数组
- 具体代码
```
function insert(arr, i, x) {
    let p = i - 1;
    while(p >= 0 && arr[p] > x) {
        arr[p+1] = arr[p];
        p--;
    }
    arr[p+1] = x;
}

function insert_sort(arr) {
    for(let i = 1; i < arr.length; i++) {
        insert(arr, i, arr[i])
    }
}

function bucket_sort(arr, k, s) {
    // 生成 k 个桶
    let buckets = Array.from({length: k}, () => []);
    // 遍历 arr 中所有的数字，将数字放在对应的桶中
    arr.forEach(number => {
        let i = Math.floor(number / s);
        buckets[i].push(number);
    })
    // 遍历每个桶，把桶中的数字进行排序
    buckets.forEach(bucket => {
        insert_sort(bucket);
    })
    // 取出同种的数字
    return [].concat(...buckets)
}

let arr = [23, 45, 12, 67, 90, 46, 7, 8, 56, 57, 43, 75, 97, 89, 86, 88 ]

console.log(bucket_sort(arr, 10, 10))
```

## 7 外部排序
数据量比较大，内存不够用时需要硬盘来协助，就需要外部排序了。外部排序的瓶颈在 I/O 操作。原因在于，内存读写是在纳秒级的，硬盘读写是毫秒级的，相差 10^6。  