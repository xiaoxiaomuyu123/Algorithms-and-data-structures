# 二、算法的衡量和优化

## 1 时间复杂度和空间复杂度

- **时间复杂度**   
时间复杂度是衡量算法执行时间随着输入规模的增加而整张的关系，是对算法的分类。用 O(n) 或者 O(n^2)
- **空间复杂度**  
空间复杂苏是指算法用了多少额外的空间，看变量的数量，用 S=C 表示。
- 思考下面的代码：这是一个翻转数组的代码。时间复杂度是 O(n)，空间复杂度是 O(n)，那么有没有办法将这个算法优化成空间复杂度是 O(1)的呢？

```
function reverse(arr) {
    const r = [];
    while(arr.length) {
        r.push(arr.pop())
    }
    return r;
}
```

## 2 合并排序   

- 将原数组差分成若干子数组，然后合并
- 时间复杂度是 O(nlgn)，空间复杂度是 O(n)，可以用于大规模的数据。
- **关键问题：如何合并两个有序数组**
    - 问题描述：  
    [3, 27, 38, 43], [9, 10, 82]  
        - 可以用一个左闭右开的区间来描述这两个数组，[0,4) [4,7)，这样刚好右边的数字见左边的数字是整个数组的长度。
        - p：代表左半边开始，p=0;   
        q: 代表左半边结束，右半边开始，q=4。  
        r：代表右半边的结束，r=7  
        - 所以问题就转换成了，怎么把数组 arr [3, 27, 38, 43, 9, 10, 82] 中的 p 到 q 的位置和 q 到 r 位置的数字的数组合并成一个有序数组。
    - 问题抽象：  
    
    `function merge(arr, p, q, r)`  
    
        - arr: 整个数组
        - p: 左半边开始的位置
        - q：左半边结束，右半边开始的位置
        - r: 右半边结束  
        - p 是实际的位置，q 和 r 是一个开区间的位置，会比实际的位置大 1。
        - q-p 是左半边数组的数量，r-q 是右半边数组的数量
    - 方法一：对 p 到 r 的元素实行插入排序。因为插入排序的复杂度是 O(n^2)，所以这个程序的复杂度是 O((r-p)^2)。消耗的时间太多
    - 方法二：对 p-r 的数组执行 Array.sort()，时间复杂度就是 O((r-p)lg(r-p))，比方法一快一些。  
    但这个方法会调用每个数组项的 toString（）方法，比较的是数字的字符串形式。所以要进行改变一下下。sort（）可以接受一个比较函数作为参数。这个比较函数接收两个参数，如果第一个参数应该位于第二个参数之前，就返回正数，否则就返回负数，相等就返回 0。
  
    ```
    function compare(v1, v2) {
    return v1-v2;
    }

    function mysort(arr) {
        arr.sort(compare);
    }
    const arr = [2, 1, 5, 3, 9]
    mysort(arr);
    console.log(arr)
    ```


   - 方法三：比前面的方法二执行的时间更短：    
        - 将数组 A 中的数字分成两组。两组分别为升序排列。例如   
        A1 = [3, 27, 38, 43， 正无穷大];  
        A2 = [9, 10, 82，正无穷大]
        - i：指向 A1 中下一个要被放回的元素
        - j：指向 A2 中下一个要被放回的元素
        - k：指向数组 A 中下一个回写的位置
        - 下面开始比较 A1 和 A2 中 i，j 指向的位置。  
        第一次，发现 3 更小，所以先回写 3。此时 k 指向 k+1 的位置，i 也要加一，指向 A1 的下一位。  
        第二次，27 和 9 比较，9 比较小，将 9 回写到 A 中，此时，k 再加一，指向 A 中下一个回写的位置，i 不变，j 加一，指向 A2 中下一位要比较的数字。  
        第三次，27 和 10 比较，写入 10；  
        第四次，27 和 82 比较，写入 82；  
        第五次，38 和 82 比较，写入 38；
        第六次，43 和 82 比较，写入 43；
        第七次，**正无穷** 和 82 比较，写入82。所以在这里正无穷的作用是保证最后一个数字可以被写入，可以不用判断是不是最后一个数字，避免写一些边界条件。最后的正无穷成为 哨兵。  
        
```
        function merge(arr, p, q, r) {

            // 将 arr 分成 arr1=[p, q) 和 arr2=[q, r) 两个数组，
            // 这样分刚好 slice（a， b）也是包含左边不包含右边的
            var arr1 = arr.slice(p, q);
            var arr2 = arr.slice(q, r);
            arr1.push(Number.MAX_SAFE_INTEGER);
            arr2.push(Number.MAX_SAFE_INTEGER);
            // 注意这里的 k 不能 等于 r，否则最后的哨兵会进入数组中进行排序，导致结果出错。
            for(let k = p, i = 0, j = 0; k < r; k++) {
                // 循环不变式
                // k ：代表 arr 中下一个回写的位置
                // i ：代表 arr1 中要比较的数字
                // j ： 代表 arr2 中要比较的数字

                // 三元表达式后面的 arr1[i++] 应该是 先执行 arr1[i]，再执行 i++ 操作
                arr[k] = arr1[i] < arr2[j] ? arr1[i++] : arr2[j++]
            }
        }

        const A = [1, 3, 5, 2, 4, 6];
        const B = [2, 4, 6, 1, 3, 5];
        const C = [2, 1];
        merge(A, 0, 3,6)
        merge(B, 0, 3,6)
        merge(C, 0, 1,2)
        console.log(A)
        console.log(B)
        console.log(C)

```   

- 归并排序的文字描述：
- 代码实现，在上面的代码基础上加上：下面的代码   

```
function merge_sort(arr, p, r) {
    if(r - p < 2) { return }
    let q = Math.ceil((r+p) / 2);
    merge_sort(arr, p, q);
    merge_sort(arr, q, r);
    merge(arr, p, q, r);
}

const arr = [3, 1, 5, 8, 6, 9];
merge_sort(arr, 0, 5);
console.log(arr)
```    

- 归并排序（合并排序）的优化：  
    - 1. 在合并两个有序数组的时候，如果后面有序数组的最后一位比前面有序数组的第一位还要小，那就说明整个后面的数组所有的数字都小于前面的数组，所以，就把最后的数组旋转操作到前面，每一次旋转一位，把这一位放在前面数组的第一位，直到最后所有的数组都被旋转移动到前面为止。
    - 问题抽象：   
    `function rotate(arr, amount, start, end)`    
        - arr：要排序的数组
        - amount：旋转次数
        - start：旋转区间开始
        - end：旋转区间结束
        - 返回值：无
        - 具体实现：旋转可以做三次反转操作来实现：
            - 第一次，将整个数组进行反转
            - 第二次，将 [start, start+amount) 反转
            - 第三次，将 [start+mount, end) 反转
    - 2. 一部分数组用插入排序，排好之后，再用合并排序。这种方法最优。  
    
## 3 递归函数复杂度分析方法   

- 树状图分析法  
以上面的合并排序为例：总用时 = 拆分用时 + 合并用时  
树的高度：H = [lgN]   以 2 为底，向上取整
时间复杂度是 O(N)，空间复杂度是 O(1)
- 递归表达式分析法
    - 推导法
    - 数学归纳法
    - 主定理